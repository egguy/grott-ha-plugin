{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"grott-ha-plugin","text":"<p>Plugin to interface Home Assistant and Grott. Allow auto discovery of the devices on Home Assistant.</p> <p>Compatibility:</p> <ul> <li>Python:<ul> <li>3.8</li> <li>3.9</li> <li>3.10</li> <li>3.11</li> </ul> </li> <li>Grott:<ul> <li>2.7.X</li> <li>2.8.X</li> </ul> </li> </ul> <p>This plugin is tested on linux (and best effort support for macOS and Windows)</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install grott-ha-plugin\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Once installed you need to add the plugin to the Grott configuration file, <code>grott.ini</code>, here an example:</p> <pre><code>[extension]\nextension=True\nextname = grottext.ha\nextvar = {\"ha_mqtt_host\": \"192.168.20.2\", \"ha_mqtt_port\": \"1883\", \"ha_mqtt_user\": \"XXXXX\", \"ha_mqtt_password\": \"XXXX\"}\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>The extension name (extname) is <code>grottext.ha</code></p> <p>The extension variable (extvar) is a json string with the following keys:</p> <ul> <li><code>ha_mqtt_host</code>: the mqtt host of the server used by Home Assistant</li> <li><code>ha_mqtt_port</code>: the mqtt port of the server used by Home Assistant</li> <li><code>ha_mqtt_user</code>: the mqtt user</li> <li><code>ha_mqtt_password</code>: the mqtt password</li> </ul>"},{"location":"#home-assistant-configuration","title":"Home assistant configuration","text":"<p>On home assistant you need to have the MQTT integration enabled (docs: https://www.home-assistant.io/integrations/mqtt/) and configured.</p> <p>You also need a MQTT broker, the recommended one is the mosquitto add-on you can install from the add-on store.</p> <p>The MQTT broker needs to have a user to allow Grott to connect to it. (This can be configured in the mosquitto add-on configuration page if you are using it)</p>"},{"location":"#home-assistant-add-on","title":"Home assistant add-on","text":"<p>There is a pre-packaged add-on existing for Home Assistant running in Home Assistant Operating System (HAOS).</p> <p>If you use the mosquitto add-on, the addon will automatically configure Grott and the plugin to use the mosquitto broker. It's a lot easier.</p> <p>The add-on is available at: - egguy HA addons - stable: The stable version (recommended) - egguy HA addons - beta: The beta version (includes the latest changes in testing) - egguy HA addons - edge: The edge version (includes the latest changes - Not recommended for day-to-day usage)</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v0100-2023-11-12","title":"v0.10.0 - 2023-11-12","text":"<p>Compare with v0.9.1</p>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Add contributing + update of the release process (cd3d5d7 by egguy).</li> <li>Add a gh-page for the documentation: https://egguy.github.io/grott-ha-plugin/</li> </ul>"},{"location":"changelog/#docs","title":"Docs","text":"<ul> <li>Update the build process of the documentation (ae4bec9 by egguy).</li> <li>Updated the documentation to make it usable on mkdocs (f5c823d by egguy).</li> </ul>"},{"location":"changelog/#v091-2023-11-07","title":"v0.9.1 - 2023-11-07","text":"<p>Compare with v0.9.0</p>"},{"location":"changelog/#v090-2023-11-06","title":"v0.9.0 - 2023-11-06","text":"<p>Compare with v0.8.2</p>"},{"location":"changelog/#v082-2023-11-06","title":"v0.8.2 - 2023-11-06","text":"<p>Compare with v0.8.1</p>"},{"location":"changelog/#v081-2023-11-06","title":"v0.8.1 - 2023-11-06","text":"<p>Compare with first commit</p>"},{"location":"changelog/#v090-2023-11-08","title":"v0.9.0 (2023-11-08)","text":""},{"location":"changelog/#features-improvements","title":"Features &amp; Improvements","text":"<ul> <li> <p>Add renovate {'[#1]'}(https://github.com/egguy/grott-ha-plugin/issues/1)</p> </li> <li> <p>Add documentation + automated release {'[#2]'}(https://github.com/egguy/grott-ha-plugin/issues/2)</p> </li> <li> <p>Update github action {'[#3]'}(https://github.com/egguy/grott-ha-plugin/issues/3)</p> </li> </ul>"},{"location":"changelog/#improved-documentation","title":"Improved Documentation","text":"<ul> <li>Improved documentation</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#environment-setup","title":"Environment setup","text":"<p>Nothing easier!</p> <p>Fork and clone the repository, then:</p> <pre><code>cd grott-ha-plugin\nmake setup\n</code></pre> <p>Note</p> <p> If it fails for some reason, you'll need to install PDM manually.</p> <p>You can install it with:</p> <pre><code>python3 -m pip install --user pipx\npipx install pdm\n</code></pre> <p>Now you can try running <code>make setup</code> again, or simply <code>pdm install</code>.</p> <p>You now have the dependencies installed.</p> <p>Run <code>make help</code> to see all the available actions!</p>"},{"location":"contributing/#tasks","title":"Tasks","text":"<p>This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you run the task directly with <code>pdm run duty TASK</code>.</p> <p>The Makefile detects if a virtual environment is activated, so <code>make</code> will work the same with the virtualenv activated or not.</p> <p>If you work in VSCode, we provide an action to configure VSCode for the project.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>As usual:</p> <ol> <li>create a new branch: <code>git switch -c feature-or-bugfix-name</code></li> <li>edit the code and/or the documentation</li> </ol> <p>Before committing:</p> <ol> <li>run <code>make format</code> to auto-format the code</li> <li>run <code>make check</code> to check everything (fix any warning)</li> <li>run <code>make test</code> to run the tests (fix any issue)</li> <li>if you updated the documentation or the project dependencies:<ol> <li>run <code>make docs</code></li> <li>go to http://localhost:8000 and check that everything looks good</li> </ol> </li> <li>follow our commit message convention</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#commit-message-convention","title":"Commit message convention","text":"<p>Commit messages must follow our convention based on the Angular style or the Karma convention:</p> <pre><code>&lt;type&gt;[(scope)]: Subject\n\n[Body]\n</code></pre> <p>Subject and body must be valid Markdown. Subject must have proper casing (uppercase for first letter if it makes sense), but no dot at the end, and no punctuation in general.</p> <p>Scope and body are optional. Type can be:</p> <ul> <li><code>build</code>: About packaging, building wheels, etc.</li> <li><code>chore</code>: About packaging or repo/files management.</li> <li><code>ci</code>: About Continuous Integration.</li> <li><code>deps</code>: Dependencies update.</li> <li><code>docs</code>: About documentation.</li> <li><code>feat</code>: New feature.</li> <li><code>fix</code>: Bug fix.</li> <li><code>perf</code>: About performance.</li> <li><code>refactor</code>: Changes that are not features or bug fixes.</li> <li><code>style</code>: A change in code style/format.</li> <li><code>tests</code>: About tests.</li> </ul> <p>If you write a body, please add trailers at the end (for example issues and PR references, or co-authors), without relying on GitHub's flavored Markdown:</p> <pre><code>Body.\n\nIssue #10: https://github.com/namespace/project/issues/10\nRelated to PR namespace/other-project#15: https://github.com/namespace/other-project/pull/15\n</code></pre> <p>These \"trailers\" must appear at the end of the body, without any blank lines between them. The trailer title can contain any character except colons <code>:</code>. We expect a full URI for each trailer, not just GitHub autolinks (for example, full GitHub URLs for commits and issues, not the hash or the #issue-number).</p> <p>We do not enforce a line length on commit messages summary and body, but please avoid very long summaries, and very long lines in the body, unless they are part of code blocks that must not be wrapped.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> grottext<ul> <li> ha<ul> <li> constants</li> <li> extension</li> <li> ha_types</li> <li> interface</li> <li> mappings</li> <li> mqtt</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/grottext/","title":"Index","text":""},{"location":"reference/grottext/#grottext","title":"grottext","text":""},{"location":"reference/grottext/ha/","title":"Index","text":""},{"location":"reference/grottext/ha/#grottext.ha","title":"ha","text":""},{"location":"reference/grottext/ha/#grottext.ha.grottext","title":"grottext","text":"<pre><code>grottext(conf: FakeConf, data: str, jsonmsg: str) -&gt; int\n</code></pre> <p>Allow pushing to HA MQTT bus, with auto discovery</p> <p>Use the plugin interface of grott to grab the raw JSON and push it to HA MQTT bus.</p> How does it work <ul> <li>Parse the raw json</li> <li>Discard if it's a buffered message</li> <li>Cleanup the values field (spaces, invalid characters)</li> <li>Check if the device is already configured</li> <li>If not, create a new sensor for each value</li> <li>Push the values to the topic <code>homeassistant/grott/{device}/state</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>conf</code>             (<code>FakeConf</code>)         \u2013          <p>The configuration object from grott</p> </li> <li> <code>data</code>             (<code>str</code>)         \u2013          <p>The raw data</p> </li> <li> <code>jsonmsg</code>             (<code>str</code>)         \u2013          <p>The raw json message</p> </li> </ul> Source code in <code>src/grottext/ha/extension.py</code> <pre><code>def grottext(conf: FakeConf, data: str, jsonmsg: str) -&gt; int:\n    \"\"\"Allow pushing to HA MQTT bus, with auto discovery\n\n    Use the plugin interface of grott to grab the raw JSON and push it to HA MQTT bus.\n\n    How does it work:\n        - Parse the raw json\n        - Discard if it's a buffered message\n        - Cleanup the values field (spaces, invalid characters)\n        - Check if the device is already configured\n        - If not, create a new sensor for each value\n        - Push the values to the topic `homeassistant/grott/{device}/state`\n\n    Parameters:\n        conf: The configuration object from grott\n        data: The raw data\n        jsonmsg: The raw json message\n    \"\"\"\n\n    required_params = [\n        MQTT_HOST_CONF_KEY,\n        MQTT_PORT_CONF_KEY,\n    ]\n    if not all(param in conf.extvar for param in required_params):\n        print(\"Missing configuration for ha_mqtt\")\n        return 1\n\n    # Need to decode the json string\n    payload = cast(Dict[str, Any], json.loads(jsonmsg))\n\n    if payload.get(\"buffered\") == \"yes\":\n        # Skip buffered message, HA don't support them\n        if conf.verbose:\n            print(\"\\t - Grott HA - skipped buffered\")\n        return 5\n\n    device_serial = payload[\"device\"]\n    values = cleanup_mqtt_values_field(payload[\"values\"])\n\n    # Send the last push in UTC with TZ\n    dt = datetime.now(timezone.utc)\n    # Add a new value to the existing values\n    values[\"grott_last_push\"] = dt.isoformat()\n\n    # Layout can be undefined\n    if not __pv_config.get(device_serial, False) and getattr(conf, \"layout\", None):\n        configs_payloads = []\n        print(f\"\\tGrott HA {__version__} - creating {device_serial} config in HA, {len(values.keys())} to push\")\n        for key in values:\n            # Prevent creating invalid MQTT topics\n            if not is_valid_mqtt_topic(key):\n                if conf.verbose:\n                    print(f\"\\t[Grott HA] {__version__} skipped key: {key} invalid name\")\n                continue\n            # Generate a configuration payload\n            try:\n                payload = make_payload(conf, device_serial, key)\n            except AttributeError as e:\n                print(f\"\\t[Grott HA] {__version__} error while generating key: {key}, error: {e}\")\n            if not payload:\n                print(f\"\\t[Grott HA] {__version__} skipped key: {key}\")\n                continue\n\n            try:\n                topic = CONFIG_TOPIC.format(\n                    sensor_type=\"sensor\",\n                    device=device_serial,\n                    attribut=key,\n                )\n                configs_payloads.append(\n                    {\n                        \"topic\": topic,\n                        \"payload\": json.dumps(payload),\n                        \"retain\": True,\n                        \"qos\": 1,\n                    }\n                )\n            except Exception as e:\n                print(f\"\\t - [grott HA] {__version__} Exception while creating new sensor {key}: {e}\")\n                return 6\n\n        # Create a virtual last_push key to allow tracking when there was the last data transmission\n\n        try:\n            key = \"grott_last_push\"\n            payload = make_payload(conf, device_serial, key)\n            topic = CONFIG_TOPIC.format(\n                sensor_type=\"sensor\",\n                device=device_serial,\n                attribut=key,\n            )\n            configs_payloads.append(\n                {\n                    \"topic\": topic,\n                    \"payload\": json.dumps(payload),\n                    \"retain\": True,\n                    \"qos\": 1,\n                }\n            )\n        except Exception as e:\n            print(f\"\\t - [grott HA] {__version__} Exception while creating new sensor last push: {e}\")\n            return 4\n        print(f\"\\tPushing {len(configs_payloads)} configurations payload to HA\")\n        publish_multiple(conf, configs_payloads)\n        print(\"\\tConfigurations pushed\")\n        # Now it's configured, no need to come back\n        __pv_config[device_serial] = True\n\n    if not __pv_config.get(device_serial, False):\n        print(f\"\\t[Grott HA] {__version__} Can't configure device: {device_serial}\")\n        return 7\n\n    # Push the values to the topic\n    retain = conf.extvar.get(MQTT_RETAIN_CONF_KEY, False)\n    if not isinstance(retain, bool):\n        retain = False\n    try:\n        publish_single(\n            conf,\n            STATE_TOPIC.format(device=device_serial),\n            json.dumps(values),\n            retain=retain,\n        )\n    except Exception as e:\n        print(f\"[HA ext] - Exception while publishing - {e}\")\n        # Reset connection state in case of a problem\n        if conf.verbose:\n            traceback.print_exc()\n        return 2\n    return 0\n</code></pre>"},{"location":"reference/grottext/ha/constants/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> constants","text":""},{"location":"reference/grottext/ha/constants/#grottext.ha.constants","title":"constants","text":""},{"location":"reference/grottext/ha/extension/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> extension","text":""},{"location":"reference/grottext/ha/extension/#grottext.ha.extension","title":"extension","text":""},{"location":"reference/grottext/ha/extension/#grottext.ha.extension.grottext","title":"grottext","text":"<pre><code>grottext(conf: FakeConf, data: str, jsonmsg: str) -&gt; int\n</code></pre> <p>Allow pushing to HA MQTT bus, with auto discovery</p> <p>Use the plugin interface of grott to grab the raw JSON and push it to HA MQTT bus.</p> How does it work <ul> <li>Parse the raw json</li> <li>Discard if it's a buffered message</li> <li>Cleanup the values field (spaces, invalid characters)</li> <li>Check if the device is already configured</li> <li>If not, create a new sensor for each value</li> <li>Push the values to the topic <code>homeassistant/grott/{device}/state</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>conf</code>             (<code>FakeConf</code>)         \u2013          <p>The configuration object from grott</p> </li> <li> <code>data</code>             (<code>str</code>)         \u2013          <p>The raw data</p> </li> <li> <code>jsonmsg</code>             (<code>str</code>)         \u2013          <p>The raw json message</p> </li> </ul> Source code in <code>src/grottext/ha/extension.py</code> <pre><code>def grottext(conf: FakeConf, data: str, jsonmsg: str) -&gt; int:\n    \"\"\"Allow pushing to HA MQTT bus, with auto discovery\n\n    Use the plugin interface of grott to grab the raw JSON and push it to HA MQTT bus.\n\n    How does it work:\n        - Parse the raw json\n        - Discard if it's a buffered message\n        - Cleanup the values field (spaces, invalid characters)\n        - Check if the device is already configured\n        - If not, create a new sensor for each value\n        - Push the values to the topic `homeassistant/grott/{device}/state`\n\n    Parameters:\n        conf: The configuration object from grott\n        data: The raw data\n        jsonmsg: The raw json message\n    \"\"\"\n\n    required_params = [\n        MQTT_HOST_CONF_KEY,\n        MQTT_PORT_CONF_KEY,\n    ]\n    if not all(param in conf.extvar for param in required_params):\n        print(\"Missing configuration for ha_mqtt\")\n        return 1\n\n    # Need to decode the json string\n    payload = cast(Dict[str, Any], json.loads(jsonmsg))\n\n    if payload.get(\"buffered\") == \"yes\":\n        # Skip buffered message, HA don't support them\n        if conf.verbose:\n            print(\"\\t - Grott HA - skipped buffered\")\n        return 5\n\n    device_serial = payload[\"device\"]\n    values = cleanup_mqtt_values_field(payload[\"values\"])\n\n    # Send the last push in UTC with TZ\n    dt = datetime.now(timezone.utc)\n    # Add a new value to the existing values\n    values[\"grott_last_push\"] = dt.isoformat()\n\n    # Layout can be undefined\n    if not __pv_config.get(device_serial, False) and getattr(conf, \"layout\", None):\n        configs_payloads = []\n        print(f\"\\tGrott HA {__version__} - creating {device_serial} config in HA, {len(values.keys())} to push\")\n        for key in values:\n            # Prevent creating invalid MQTT topics\n            if not is_valid_mqtt_topic(key):\n                if conf.verbose:\n                    print(f\"\\t[Grott HA] {__version__} skipped key: {key} invalid name\")\n                continue\n            # Generate a configuration payload\n            try:\n                payload = make_payload(conf, device_serial, key)\n            except AttributeError as e:\n                print(f\"\\t[Grott HA] {__version__} error while generating key: {key}, error: {e}\")\n            if not payload:\n                print(f\"\\t[Grott HA] {__version__} skipped key: {key}\")\n                continue\n\n            try:\n                topic = CONFIG_TOPIC.format(\n                    sensor_type=\"sensor\",\n                    device=device_serial,\n                    attribut=key,\n                )\n                configs_payloads.append(\n                    {\n                        \"topic\": topic,\n                        \"payload\": json.dumps(payload),\n                        \"retain\": True,\n                        \"qos\": 1,\n                    }\n                )\n            except Exception as e:\n                print(f\"\\t - [grott HA] {__version__} Exception while creating new sensor {key}: {e}\")\n                return 6\n\n        # Create a virtual last_push key to allow tracking when there was the last data transmission\n\n        try:\n            key = \"grott_last_push\"\n            payload = make_payload(conf, device_serial, key)\n            topic = CONFIG_TOPIC.format(\n                sensor_type=\"sensor\",\n                device=device_serial,\n                attribut=key,\n            )\n            configs_payloads.append(\n                {\n                    \"topic\": topic,\n                    \"payload\": json.dumps(payload),\n                    \"retain\": True,\n                    \"qos\": 1,\n                }\n            )\n        except Exception as e:\n            print(f\"\\t - [grott HA] {__version__} Exception while creating new sensor last push: {e}\")\n            return 4\n        print(f\"\\tPushing {len(configs_payloads)} configurations payload to HA\")\n        publish_multiple(conf, configs_payloads)\n        print(\"\\tConfigurations pushed\")\n        # Now it's configured, no need to come back\n        __pv_config[device_serial] = True\n\n    if not __pv_config.get(device_serial, False):\n        print(f\"\\t[Grott HA] {__version__} Can't configure device: {device_serial}\")\n        return 7\n\n    # Push the values to the topic\n    retain = conf.extvar.get(MQTT_RETAIN_CONF_KEY, False)\n    if not isinstance(retain, bool):\n        retain = False\n    try:\n        publish_single(\n            conf,\n            STATE_TOPIC.format(device=device_serial),\n            json.dumps(values),\n            retain=retain,\n        )\n    except Exception as e:\n        print(f\"[HA ext] - Exception while publishing - {e}\")\n        # Reset connection state in case of a problem\n        if conf.verbose:\n            traceback.print_exc()\n        return 2\n    return 0\n</code></pre>"},{"location":"reference/grottext/ha/ha_types/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> ha_types","text":""},{"location":"reference/grottext/ha/ha_types/#grottext.ha.ha_types","title":"ha_types","text":""},{"location":"reference/grottext/ha/ha_types/#grottext.ha.ha_types.to_dict","title":"to_dict","text":"<pre><code>to_dict(obj: Any) -&gt; Dict[str, Any]\n</code></pre> <p>Convert a dataclass object to dict</p> <p>Parameters:</p> <ul> <li> <code>obj</code>             (<code>Any</code>)         \u2013          <p>The sensor object to convert</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>         \u2013          <p>A dictionary representation of the object</p> </li> </ul> Source code in <code>src/grottext/ha/ha_types.py</code> <pre><code>def to_dict(obj: Any) -&gt; Dict[str, Any]:\n    \"\"\"Convert a dataclass object to dict\n\n    Parameters:\n        obj: The sensor object to convert\n\n    Returns:\n        A dictionary representation of the object\n    \"\"\"\n    dict_obj = asdict(obj)\n    # Remove None values\n    return {k: v for k, v in dict_obj.items() if v is not None}\n</code></pre>"},{"location":"reference/grottext/ha/interface/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> interface","text":""},{"location":"reference/grottext/ha/interface/#grottext.ha.interface","title":"interface","text":""},{"location":"reference/grottext/ha/interface/#grottext.ha.interface.FakeConf","title":"FakeConf","text":"<pre><code>FakeConf()\n</code></pre> <p>A fake configuration object imitating the one from grott.</p> <p>This is a fake object</p> <p>Only used for testing.</p> Source code in <code>src/grottext/ha/interface.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.recorddict: Dict[str, Any] = {}\n    self.layout = \"\"\n    self.extvar: Dict[str, Union[str, int, bool]] = {}\n    self.verbose = True\n</code></pre>"},{"location":"reference/grottext/ha/mappings/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> mappings","text":""},{"location":"reference/grottext/ha/mappings/#grottext.ha.mappings","title":"mappings","text":""},{"location":"reference/grottext/ha/mqtt/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> mqtt","text":""},{"location":"reference/grottext/ha/mqtt/#grottext.ha.mqtt","title":"mqtt","text":""},{"location":"reference/grottext/ha/mqtt/#grottext.ha.mqtt.cleanup_mqtt_values_field","title":"cleanup_mqtt_values_field","text":"<pre><code>cleanup_mqtt_values_field(\n    values: Dict[str, Any]\n) -&gt; Dict[str, Any]\n</code></pre> <p>Cleanup the values from invalid keys</p> <p>Drop the possible invalid keys from the values and normalize the keys.</p> <p>Parameters:</p> <ul> <li> <code>values</code>             (<code>Dict[str, Any]</code>)         \u2013          <p>Original dict</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>         \u2013          <p>The cleaned-up values</p> </li> </ul> Source code in <code>src/grottext/ha/mqtt.py</code> <pre><code>def cleanup_mqtt_values_field(values: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Cleanup the values from invalid keys\n\n    Drop the possible invalid keys from the values and normalize the keys.\n\n    Parameters:\n        values: Original dict\n\n    Returns:\n        The cleaned-up values\n    \"\"\"\n    return {k.strip(): v for k, v in values.items() if is_valid_mqtt_topic(k)}\n</code></pre>"},{"location":"reference/grottext/ha/mqtt/#grottext.ha.mqtt.is_valid_mqtt_topic","title":"is_valid_mqtt_topic","text":"<pre><code>is_valid_mqtt_topic(key_name: str) -&gt; bool\n</code></pre> <p>Check if the key is a valid mqtt topic</p> <p>Look If the possible topic is valid, based on the MQTT spec and reserved keywords</p> <p>Parameters:</p> <ul> <li> <code>key_name</code>             (<code>str</code>)         \u2013          <p>The value of the key (e.g. \"ACDischarWatt\")</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if the key is a valid mqtt topic, False otherwise</p> </li> </ul> Source code in <code>src/grottext/ha/mqtt.py</code> <pre><code>def is_valid_mqtt_topic(key_name: str) -&gt; bool:\n    \"\"\"Check if the key is a valid mqtt topic\n\n    Look If the possible topic is valid, based on the MQTT spec and reserved keywords\n\n    Parameters:\n        key_name: The value of the key (e.g. \"ACDischarWatt\")\n\n    Returns:\n         True if the key is a valid mqtt topic, False otherwise\n    \"\"\"\n    key_name = key_name.strip()\n    # Character used to bind wildcard topics\n    if key_name.startswith(\"#\"):\n        return False\n    # Character used to bind single level topics\n    if key_name.startswith(\"+\"):\n        return False\n    # should not start or end with /\n    if key_name.startswith(\"/\"):\n        return False\n    if key_name.endswith(\"/\"):\n        return False\n    # system topics\n    if key_name.startswith(\"$\"):\n        return False\n    return True\n</code></pre>"},{"location":"reference/grottext/ha/mqtt/#grottext.ha.mqtt.make_payload","title":"make_payload","text":"<pre><code>make_payload(\n    conf: FakeConf,\n    device: str,\n    key: str,\n    name: Optional[str] = None,\n) -&gt; Dict[str, str]\n</code></pre> <p>Generate a MQTT payload for a sensor</p> <p>Use default values to create a sensor payload, then update with custom attributes if they exist. E.g., unit_of_measurement/total increasing/etc.</p> <p>Parameters:</p> <ul> <li> <code>conf</code>             (<code>FakeConf</code>)         \u2013          <p>The configuration object, used to extract default divider</p> </li> <li> <code>device</code>             (<code>str</code>)         \u2013          <p>Use the device name as part of the sensor name + device</p> </li> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>The key of the sensor sent by grott</p> </li> <li> <code>name</code>             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>The name of the sensor, if you want something different</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>         \u2013          <p>A dictionary with the MQTT configuration payload</p> </li> </ul> Source code in <code>src/grottext/ha/mqtt.py</code> <pre><code>def make_payload(conf: FakeConf, device: str, key: str, name: Optional[str] = None) -&gt; Dict[str, str]:\n    \"\"\"Generate a MQTT payload for a sensor\n\n    Use default values to create a sensor payload, then update with custom\n    attributes if they exist.\n    E.g., unit_of_measurement/total increasing/etc.\n\n    Parameters:\n        conf: The configuration object, used to extract default divider\n        device: Use the device name as part of the sensor name + device\n        key: The key of the sensor sent by grott\n        name: The name of the sensor, if you want something different\n\n    Returns:\n        A dictionary with the MQTT configuration payload\n    \"\"\"\n\n    if not device:\n        msg = \"device is required\"\n        raise AttributeError(msg)\n    if not key:\n        msg = \"key is required\"\n        raise AttributeError(msg)\n    if not conf.layout:\n        msg = \"grott config class error\"\n        raise AttributeError(msg)\n    if conf.layout not in conf.recorddict:\n        msg = \"grott config class error, missing record layout\"\n        raise AttributeError(msg)\n\n    if name is None:\n        name = key\n\n    sensor = mapping.get(key, None)\n\n    value_template = None\n    if sensor and sensor.value_template:\n        value_template = sensor.value_template\n    else:\n        # Reuse the existing divide value if available and not existing\n        # and apply it to the HA config\n        layout = conf.recorddict[conf.layout]\n        if key in layout:\n            # From grottdata:207, default type is num, also process numx\n            register_type = layout[key].get(\"type\", \"num\")\n            # The register is a numerical type\n            if register_type in (\"num\", \"numx\"):\n                # default divide is 1, if not found\n                divider = layout[key].get(\"divide\", \"1\")\n                value_template = f\"{{{{ value_json.{key} | float / {divider} }}}}\"\n            elif register_type == \"log\":\n                # register is already a float, no need to divide\n                value_template = f\"{{{{ value_json.{key} | float }}}}\"\n            elif register_type == \"logpos\":\n                # register is already a float, no need to divide\n                value_template = f\"{{{{ [value_json.{key} | float, 0.0] | max }}}}\"\n            elif register_type == \"logneg\":\n                # register is already a float, no need to divide\n                value_template = f\"{{{{ [value_json.{key} | float, 0.0] | min }}}}\"\n\n    if value_template is None:\n        value_template = f\"{{{{ value_json.{key} }}}}\"\n\n    # Default configuration payload\n    payload = MQTTConfigPayload(\n        name=\"{name}\",\n        unique_id=f\"grott_{device}_{key}\",  # Generate a unique device ID\n        state_topic=f\"homeassistant/grott/{device}/state\",\n        device=Device(\n            identifiers=[device],  # Group under a device\n            name=device,\n            manufacturer=\"GrowWatt\",\n        ),\n        value_template=value_template,\n    )\n\n    if sensor is not None:\n        # Update the payload with the sensor configuration\n        payload.name = sensor.name\n        payload.icon = sensor.icon\n        payload.state_class = sensor.state_class\n        payload.device_class = sensor.device_class\n        payload.icon = sensor.icon\n        payload.entity_category = sensor.entity_category\n        payload.unit_of_measurement = sensor.unit_of_measurement\n\n    # Generate the name of the key, with all the param available\n    payload.name = payload.name.format(device=device, name=name, key=key)\n    # HA automatically group the sensors if the device name is prepended\n\n    return to_dict(payload)\n</code></pre>"},{"location":"coverage/","title":"Coverage report","text":""}]}